#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
è‹±èªéŸ³å£°â†’æ—¥æœ¬èªå­—å¹•ç”Ÿæˆãƒ„ãƒ¼ãƒ«ï¼ˆWAVå°‚ç”¨ãƒ»FFmpegä¸è¦ç‰ˆï¼‰
English Speech to Japanese Subtitle Generator (WAV Only)

WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å¯¾å¿œã€FFmpegã¨pydubä¸è¦
ä½œè€…: yukiko (AIãƒ»BIã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢è»¢è·æ´»å‹•ä¸­)
"""

# æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import os          # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ“ä½œç”¨
import sys         # ã‚·ã‚¹ãƒ†ãƒ é–¢é€£ã®æ“ä½œç”¨
from datetime import datetime, timedelta  # æ—¥æ™‚æ“ä½œç”¨

# å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å®‰å…¨ã«è¡Œã†
# try-exceptæ–‡ã§å›²ã‚€ã“ã¨ã§ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒä¸è¶³ã—ã¦ã„ã¦ã‚‚ã‚¨ãƒ©ãƒ¼ã§æ­¢ã¾ã‚‰ãªã„
try:
    import json                             # JSONå½¢å¼ã®ãƒ‡ãƒ¼ã‚¿å‡¦ç†ç”¨ï¼ˆä½¿ç”¨äºˆå®šï¼‰
    import threading                        # ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰å‡¦ç†ç”¨ï¼ˆGUIå¿œç­”æ€§å‘ä¸Šï¼‰
    import tkinter as tk                    # GUIä½œæˆç”¨ãƒ¡ã‚¤ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
    from tkinter import filedialog, messagebox, scrolledtext, ttk  # GUIéƒ¨å“
    from openai import OpenAI               # OpenAI APIé€£æºç”¨
    import wave                             # WAVãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ç”¨
    import configparser                     # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿æ›¸ãç”¨
    import re                               # æ­£è¦è¡¨ç¾å‡¦ç†ç”¨ï¼ˆä½¿ç”¨äºˆå®šï¼‰
    IMPORTS_OK = True                       # ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸãƒ•ãƒ©ã‚°
    MISSING_MODULE = ""                     # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ ¼ç´ç”¨
except ImportError as e:                    # ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆ
    IMPORTS_OK = False                      # ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—ãƒ•ãƒ©ã‚°
    MISSING_MODULE = str(e)                 # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ–‡å­—åˆ—ã§ä¿å­˜

class EnglishToJapaneseSubtitle:
    """
    è‹±èªéŸ³å£°ã‚’æ—¥æœ¬èªå­—å¹•ã«å¤‰æ›ã™ã‚‹ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹
    OpenAI APIã‚’ä½¿ç”¨ã—ã¦éŸ³å£°èªè­˜ã¨ç¿»è¨³ã‚’è¡Œã†
    """
    
    def __init__(self, api_key=None):
        """
        ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–ãƒ¡ã‚½ãƒƒãƒ‰
        Args:
            api_key: OpenAI APIã‚­ãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        """
        # ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå¤±æ•—ã—ã¦ã„ãŸå ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
        if not IMPORTS_OK:
            return
        
        # OpenAI APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–ï¼ˆæœ€åˆã¯Noneï¼‰
        self.client = None
        
        # APIã‚­ãƒ¼ãŒæ¸¡ã•ã‚Œã¦ã„ã‚Œã°è¨­å®šã™ã‚‹
        if api_key:
            self.set_api_key(api_key)
    
    def set_api_key(self, api_key):
        """
        OpenAI APIã‚­ãƒ¼ã‚’è¨­å®šã—ã€æ¥ç¶šã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹
        Args:
            api_key: OpenAI APIã‚­ãƒ¼
        Returns:
            bool: è¨­å®šæˆåŠŸæ™‚Trueã€å¤±æ•—æ™‚False
        """
        try:
            # OpenAIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–
            self.client = OpenAI(api_key=api_key)  # APIã‚­ãƒ¼ã‚’è¨­å®š
            
            # APIã‚­ãƒ¼ã®æœ‰åŠ¹æ€§ã‚’ãƒ†ã‚¹ãƒˆï¼ˆãƒ¢ãƒ‡ãƒ«ä¸€è¦§ã‚’å–å¾—ï¼‰
            self.client.models.list()              # å®Ÿéš›ã«APIã‚’å‘¼ã³å‡ºã—ã¦ãƒ†ã‚¹ãƒˆ
            return True                             # æˆåŠŸæ™‚ã¯Trueã‚’è¿”ã™
        except Exception as e:                      # ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆ
            print(f"APIã‚­ãƒ¼è¨­å®šã‚¨ãƒ©ãƒ¼: {e}")        # ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
            self.client = None                      # ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
            return False                            # å¤±æ•—æ™‚ã¯Falseã‚’è¿”ã™
    
    def validate_wav_file(self, wav_file):
        """
        WAVãƒ•ã‚¡ã‚¤ãƒ«ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
        ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã€ã‚µã‚¤ã‚ºã€éŸ³è³ªãªã©ã‚’ç¢ºèª
        Args:
            wav_file: WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        Returns:
            tuple: (æˆåŠŸãƒ•ãƒ©ã‚°, ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        try:
            # WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ãƒ¢ãƒ¼ãƒ‰ã§é–‹ã
            with wave.open(wav_file, 'rb') as wf:   # 'rb'ã¯ãƒã‚¤ãƒŠãƒªèª­ã¿è¾¼ã¿ãƒ¢ãƒ¼ãƒ‰
                # ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’å–å¾—
                channels = wf.getnchannels()        # ãƒãƒ£ãƒ³ãƒãƒ«æ•°ï¼ˆãƒ¢ãƒãƒ©ãƒ«=1ã€ã‚¹ãƒ†ãƒ¬ã‚ª=2ï¼‰
                sample_width = wf.getsampwidth()    # ã‚µãƒ³ãƒ—ãƒ«å¹…ï¼ˆãƒã‚¤ãƒˆæ•°ï¼‰
                framerate = wf.getframerate()       # ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆï¼ˆHzï¼‰
                frames = wf.getnframes()            # ç·ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
                duration = frames / float(framerate)  # é•·ã•ã‚’ç§’ã§è¨ˆç®—
                
                # ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                print(f"WAVãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±:")
                print(f"  ãƒãƒ£ãƒ³ãƒãƒ«æ•°: {channels}")           # 1=ãƒ¢ãƒãƒ©ãƒ«, 2=ã‚¹ãƒ†ãƒ¬ã‚ª
                print(f"  ã‚µãƒ³ãƒ—ãƒ«å¹…: {sample_width} bytes")   # é€šå¸¸ã¯2ãƒã‚¤ãƒˆï¼ˆ16bitï¼‰
                print(f"  ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ: {framerate} Hz")     # éŸ³è³ªã‚’æ±ºã‚ã‚‹é‡è¦ãªå€¤
                print(f"  é•·ã•: {duration:.2f} ç§’")            # å°æ•°ç‚¹ä»¥ä¸‹2æ¡ã§è¡¨ç¤º
                
                # ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆOpenAI APIã®åˆ¶é™ã¯25MBï¼‰
                file_size = os.path.getsize(wav_file)           # ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’å–å¾—ï¼ˆãƒã‚¤ãƒˆï¼‰
                if file_size > 25 * 1024 * 1024:                # 25MB = 25 * 1024 * 1024 bytes
                    # ã‚µã‚¤ã‚ºã‚ªãƒ¼ãƒãƒ¼ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
                    return False, f"ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™: {file_size / (1024*1024):.1f}MBï¼ˆä¸Šé™: 25MBï¼‰"
                
                # ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ãŒé€šã£ãŸå ´åˆ
                return True, "WAVãƒ•ã‚¡ã‚¤ãƒ«ã¯æœ‰åŠ¹ã§ã™"
                
        except Exception as e:                       # WAVãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼
            return False, f"WAVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}"
    
    def transcribe_english_with_timestamps(self, audio_file):
        """
        è‹±èªéŸ³å£°ã‚’ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãã§èªè­˜ã™ã‚‹
        OpenAI Whisper APIã‚’ä½¿ç”¨
        Args:
            audio_file: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        Returns:
            dict: èªè­˜çµæœï¼ˆãƒ†ã‚­ã‚¹ãƒˆã€è¨€èªã€é•·ã•ã€ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ï¼‰
        """
        # APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
        if self.client is None:
            return "OpenAI APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"
        
        # WAVãƒ•ã‚¡ã‚¤ãƒ«ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        is_valid, message = self.validate_wav_file(audio_file)  # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        if not is_valid:                                        # ãƒã‚§ãƒƒã‚¯å¤±æ•—æ™‚
            return message                                       # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
        
        try:
            # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§é–‹ã
            with open(audio_file, "rb") as audio:               # 'rb'ã¯ãƒã‚¤ãƒŠãƒªèª­ã¿è¾¼ã¿
                # æ–°ã—ã„APIãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¯¾å¿œ
                try:
                    # æ–°ã—ã„APIï¼ˆtimestamp_granularitieså¯¾å¿œï¼‰ã‚’è©¦ã™
                    transcript = self.client.audio.transcriptions.create(
                        model="whisper-1",                      # Whisperãƒ¢ãƒ‡ãƒ«ã‚’æŒ‡å®š
                        file=audio,                             # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«
                        language="en",                          # è¨€èªã‚’è‹±èªã«æŒ‡å®š
                        response_format="verbose_json",         # è©³ç´°ãªJSONå½¢å¼ã§çµæœã‚’å–å¾—
                        timestamp_granularities=["segment"]     # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå˜ä½ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
                    )
                except Exception as new_api_error:              # æ–°ã—ã„APIã§ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
                    # å¤ã„APIï¼ˆtimestamp_granularitiesæœªå¯¾å¿œï¼‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    audio.seek(0)                               # ãƒ•ã‚¡ã‚¤ãƒ«ãƒã‚¤ãƒ³ã‚¿ã‚’å…ˆé ­ã«æˆ»ã™
                    transcript = self.client.audio.transcriptions.create(
                        model="whisper-1",                      # Whisperãƒ¢ãƒ‡ãƒ«ã‚’æŒ‡å®š
                        file=audio,                             # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«
                        language="en",                          # è¨€èªã‚’è‹±èªã«æŒ‡å®š
                        response_format="verbose_json"          # è©³ç´°ãªJSONå½¢å¼ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãªã—ï¼‰
                    )
            
            # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’å«ã‚€çµæœã‚’è¾æ›¸å½¢å¼ã§è¿”ã™
            result = {
                'text': transcript.text,                        # èªè­˜ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“
                'language': transcript.language,                # æ¤œå‡ºã•ã‚ŒãŸè¨€èª
                'duration': transcript.duration,                # éŸ³å£°ã®é•·ã•ï¼ˆç§’ï¼‰
                'segments': transcript.segments if hasattr(transcript, 'segments') else []  # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±
            }
            
            return result                                       # çµæœã‚’è¿”ã™
        except Exception as e:                                  # ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼
            return f"è‹±èªéŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: {e}"                   # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
    
    def translate_to_japanese(self, english_text, context="subtitle"):
        """
        è‹±èªãƒ†ã‚­ã‚¹ãƒˆã‚’æ—¥æœ¬èªã«ç¿»è¨³ã™ã‚‹
        OpenAI GPT-4ã‚’ä½¿ç”¨ã—ã¦å­—å¹•ã«é©ã—ãŸè‡ªç„¶ãªç¿»è¨³ã‚’è¡Œã†
        Args:
            english_text: ç¿»è¨³ã™ã‚‹è‹±èªãƒ†ã‚­ã‚¹ãƒˆ
            context: ç¿»è¨³ã®æ–‡è„ˆï¼ˆ"subtitle"ãªã©ï¼‰
        Returns:
            str: ç¿»è¨³ã•ã‚ŒãŸæ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ
        """
        # APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
        if self.client is None:
            return "OpenAI APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"
        
        try:
            # ç¿»è¨³ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®è¨­å®š
            if context == "subtitle":                           # å­—å¹•ç¿»è¨³ã®å ´åˆ
                # å­—å¹•å°‚ç”¨ã®è©³ç´°ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®š
                system_prompt = """ã‚ãªãŸã¯æ˜ åƒå­—å¹•ã®å°‚é–€ç¿»è¨³è€…ã§ã™ã€‚ä»¥ä¸‹ã®è‹±èªãƒ†ã‚­ã‚¹ãƒˆã‚’è‡ªç„¶ã§èª­ã¿ã‚„ã™ã„æ—¥æœ¬èªå­—å¹•ã«ç¿»è¨³ã—ã¦ãã ã•ã„ã€‚

ç¿»è¨³ã®éš›ã®æ³¨æ„äº‹é …ï¼š
- å­—å¹•ã¨ã—ã¦èª­ã¿ã‚„ã™ã„è‡ªç„¶ãªæ—¥æœ¬èªã«ã™ã‚‹
- æ–‡è„ˆã‚’è€ƒæ…®ã—ã€æ˜ åƒã«åˆã†è¡¨ç¾ã‚’ä½¿ã†
- æ•¬èªã¯æ–‡è„ˆã«å¿œã˜ã¦é©åˆ‡ã«ä½¿ç”¨
- å°‚é–€ç”¨èªã¯æ—¥æœ¬èªã§ä¸€èˆ¬çš„ãªè¡¨ç¾ã‚’ä½¿ç”¨
- é•·ã™ãã‚‹æ–‡ã¯é©åˆ‡ã«åˆ†å‰²ã™ã‚‹
"""
            else:                                               # ãã®ä»–ã®ç¿»è¨³ã®å ´åˆ
                # ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
                system_prompt = "ä»¥ä¸‹ã®è‹±èªãƒ†ã‚­ã‚¹ãƒˆã‚’è‡ªç„¶ãªæ—¥æœ¬èªã«ç¿»è¨³ã—ã¦ãã ã•ã„ã€‚"
            
            # OpenAI GPT-4 APIã‚’å‘¼ã³å‡ºã—
            response = self.client.chat.completions.create(
                model="gpt-4",                                  # GPT-4ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
                messages=[                                      # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—
                    {"role": "system", "content": system_prompt},  # ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆç¿»è¨³æŒ‡ç¤ºï¼‰
                    {"role": "user", "content": english_text}       # ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ï¼ˆç¿»è¨³å¯¾è±¡ãƒ†ã‚­ã‚¹ãƒˆï¼‰
                ],
                temperature=0.3                                 # å‰µé€ æ€§ã‚’æŠ‘ãˆã¦ä¸€è²«ã—ãŸç¿»è¨³ã«ã™ã‚‹
            )
            
            # ç¿»è¨³çµæœã‚’å–å¾—ã—ã¦å‰å¾Œã®ç©ºç™½ã‚’å‰Šé™¤
            return response.choices[0].message.content.strip()
        except Exception as e:                                  # ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆ
            return f"ç¿»è¨³ã‚¨ãƒ©ãƒ¼: {e}"                           # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
    
    def create_subtitle_segments(self, transcription_result):
        """
        éŸ³å£°èªè­˜çµæœã‹ã‚‰å­—å¹•ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
        å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’è‹±èªã‹ã‚‰æ—¥æœ¬èªã«ç¿»è¨³
        Args:
            transcription_result: éŸ³å£°èªè­˜ã®çµæœ
        Returns:
            list: å­—å¹•ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ãƒªã‚¹ãƒˆ
        """
        # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¿”ã£ã¦ããŸå ´åˆã¯ãã®ã¾ã¾è¿”ã™
        if isinstance(transcription_result, str):
            return transcription_result
        
        # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’å–å¾—ï¼ˆãªã‘ã‚Œã°ç©ºã®ãƒªã‚¹ãƒˆï¼‰
        segments = transcription_result.get('segments', [])
        
        if not segments:                                        # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ãŒãªã„å ´åˆ
            # å…¨ä½“ã‚’1ã¤ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨ã—ã¦å‡¦ç†
            english_text = transcription_result.get('text', '')  # å…¨ä½“ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            japanese_text = self.translate_to_japanese(english_text)  # ç¿»è¨³å®Ÿè¡Œ
            return [{                                           # 1ã¤ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨ã—ã¦è¿”ã™
                'start': 0,                                     # é–‹å§‹æ™‚é–“ã¯0ç§’
                'end': transcription_result.get('duration', 0), # çµ‚äº†æ™‚é–“ã¯éŸ³å£°ã®é•·ã•
                'english': english_text,                       # è‹±èªãƒ†ã‚­ã‚¹ãƒˆ
                'japanese': japanese_text                       # æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ
            }]
        
        # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã”ã¨ã®å‡¦ç†
        subtitle_segments = []                                  # çµæœæ ¼ç´ç”¨ã®ãƒªã‚¹ãƒˆ
        for segment in segments:                                # å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å‡¦ç†
            english_text = segment.get('text', '').strip()      # è‹±èªãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ã—ç©ºç™½å‰Šé™¤
            if english_text:                                    # ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚‹å ´åˆã®ã¿å‡¦ç†
                japanese_text = self.translate_to_japanese(english_text)  # ç¿»è¨³å®Ÿè¡Œ
                subtitle_segments.append({                      # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’è¿½åŠ 
                    'start': segment.get('start', 0),           # é–‹å§‹æ™‚é–“
                    'end': segment.get('end', 0),               # çµ‚äº†æ™‚é–“
                    'english': english_text,                   # è‹±èªãƒ†ã‚­ã‚¹ãƒˆ
                    'japanese': japanese_text                   # æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ
                })
        
        return subtitle_segments                                # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãƒªã‚¹ãƒˆã‚’è¿”ã™
    
    def format_time_srt(self, seconds):
        """
        ç§’æ•°ã‚’SRTå½¢å¼ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã«å¤‰æ›ã™ã‚‹
        SRTå½¢å¼: HH:MM:SS,mmm (ä¾‹: 00:01:23,456)
        Args:
            seconds: ç§’æ•°ï¼ˆfloatï¼‰
        Returns:
            str: SRTå½¢å¼ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
        """
        td = timedelta(seconds=seconds)                         # timedelta ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
        hours = int(td.total_seconds() // 3600)                 # æ™‚é–“ã‚’è¨ˆç®—ï¼ˆ3600ç§’ = 1æ™‚é–“ï¼‰
        minutes = int((td.total_seconds() % 3600) // 60)        # åˆ†ã‚’è¨ˆç®—ï¼ˆ60ç§’ = 1åˆ†ï¼‰
        secs = int(td.total_seconds() % 60)                     # ç§’ã‚’è¨ˆç®—
        millisecs = int((td.total_seconds() % 1) * 1000)        # ãƒŸãƒªç§’ã‚’è¨ˆç®—
        # SRTå½¢å¼ã®æ–‡å­—åˆ—ã‚’è¿”ã™ï¼ˆHH:MM:SS,mmmï¼‰
        return f"{hours:02d}:{minutes:02d}:{secs:02d},{millisecs:03d}"
    
    def generate_srt_content(self, subtitle_segments):
        """
        SRTå½¢å¼ã®å­—å¹•ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆã™ã‚‹
        å‹•ç”»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ä½¿ç”¨å¯èƒ½ãªæ¨™æº–çš„ãªå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
        Args:
            subtitle_segments: å­—å¹•ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ãƒªã‚¹ãƒˆ
        Returns:
            str: SRTå½¢å¼ã®å­—å¹•å†…å®¹
        """
        srt_content = ""                                        # çµæœæ ¼ç´ç”¨ã®æ–‡å­—åˆ—
        for i, segment in enumerate(subtitle_segments, 1):      # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’1ã‹ã‚‰ç•ªå·ä»˜ã‘ã—ã¦å‡¦ç†
            start_time = self.format_time_srt(segment['start']) # é–‹å§‹æ™‚é–“ã‚’SRTå½¢å¼ã«å¤‰æ›
            end_time = self.format_time_srt(segment['end'])     # çµ‚äº†æ™‚é–“ã‚’SRTå½¢å¼ã«å¤‰æ›
            
            # SRTå½¢å¼ã«å¾“ã£ã¦å­—å¹•ã‚’çµ„ã¿ç«‹ã¦
            srt_content += f"{i}\n"                             # å­—å¹•ç•ªå·
            srt_content += f"{start_time} --> {end_time}\n"     # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
            srt_content += f"{segment['japanese']}\n\n"         # æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ + ç©ºè¡Œ
        
        return srt_content                                      # SRTå½¢å¼ã®æ–‡å­—åˆ—ã‚’è¿”ã™
    
    def generate_bilingual_text(self, subtitle_segments):
        """
        è‹±æ—¥å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹
        å­¦ç¿’ã‚„ç¢ºèªç”¨ã®èª­ã¿ã‚„ã™ã„å½¢å¼
        Args:
            subtitle_segments: å­—å¹•ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ãƒªã‚¹ãƒˆ
        Returns:
            str: è‹±æ—¥å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆ
        """
        # ãƒ˜ãƒƒãƒ€ãƒ¼éƒ¨åˆ†ã‚’ä½œæˆ
        text_content = "=" * 60 + "\n"                          # åŒºåˆ‡ã‚Šç·š
        text_content += "è‹±èªéŸ³å£° â†’ æ—¥æœ¬èªå­—å¹•\n"               # ã‚¿ã‚¤ãƒˆãƒ«
        text_content += f"ç”Ÿæˆæ—¥æ™‚: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"  # ç¾åœ¨æ™‚åˆ»
        text_content += "=" * 60 + "\n\n"                       # åŒºåˆ‡ã‚Šç·š + ç©ºè¡Œ
        
        # å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å‡¦ç†
        for i, segment in enumerate(subtitle_segments, 1):      # 1ã‹ã‚‰ç•ªå·ä»˜ã‘
            start_time = self.format_time_display(segment['start'])  # è¡¨ç¤ºç”¨æ™‚é–“ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            end_time = self.format_time_display(segment['end'])      # è¡¨ç¤ºç”¨æ™‚é–“ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            
            # å¯¾è¨³å½¢å¼ã§å†…å®¹ã‚’çµ„ã¿ç«‹ã¦
            text_content += f"[{i:03d}] {start_time} - {end_time}\n"  # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆç•ªå·ã¨æ™‚é–“
            text_content += f"EN: {segment['english']}\n"              # è‹±èªãƒ†ã‚­ã‚¹ãƒˆ
            text_content += f"JA: {segment['japanese']}\n"             # æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ
            text_content += "-" * 40 + "\n\n"                          # åŒºåˆ‡ã‚Šç·š + ç©ºè¡Œ
        
        return text_content                                     # å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã™
    
    def format_time_display(self, seconds):
        """
        è¡¨ç¤ºç”¨ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        MM:SS å½¢å¼ï¼ˆåˆ†:ç§’ï¼‰ã§ã‚·ãƒ³ãƒ—ãƒ«ã«è¡¨ç¤º
        Args:
            seconds: ç§’æ•°
        Returns:
            str: MM:SSå½¢å¼ã®æ™‚é–“æ–‡å­—åˆ—
        """
        minutes = int(seconds // 60)                            # åˆ†ã‚’è¨ˆç®—
        secs = int(seconds % 60)                                # ç§’ã‚’è¨ˆç®—
        return f"{minutes:02d}:{secs:02d}"                      # MM:SSå½¢å¼ã§è¿”ã™
    
    def process_wav_file(self, file_path, progress_callback=None):
        """
        WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†ã—ã¦å­—å¹•ã‚’ç”Ÿæˆã™ã‚‹
        éŸ³å£°èªè­˜â†’ç¿»è¨³â†’å­—å¹•ç”Ÿæˆã®å…¨å·¥ç¨‹ã‚’å®Ÿè¡Œ
        Args:
            file_path: WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            progress_callback: é€²æ—è¡¨ç¤ºç”¨ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
        Returns:
            dict: å‡¦ç†çµæœï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆã€å…ƒãƒ†ã‚­ã‚¹ãƒˆã€é•·ã•ï¼‰
        """
        try:
            # é€²æ—è¡¨ç¤ºï¼ˆã‚¹ãƒ†ãƒƒãƒ—1ï¼‰
            if progress_callback:
                progress_callback("WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªä¸­...")
            
            # WAVãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ãƒã‚§ãƒƒã‚¯
            if not file_path.lower().endswith('.wav'):          # æ‹¡å¼µå­ãŒ.wavä»¥å¤–ã®å ´åˆ
                return "WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ä»–ã®å½¢å¼ã¯äº‹å‰ã«WAVã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"
            
            # é€²æ—è¡¨ç¤ºï¼ˆã‚¹ãƒ†ãƒƒãƒ—2ï¼‰
            if progress_callback:
                progress_callback("è‹±èªéŸ³å£°ã‚’èªè­˜ä¸­...")
            
            # è‹±èªéŸ³å£°èªè­˜ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãï¼‰
            transcription_result = self.transcribe_english_with_timestamps(file_path)
            
            # éŸ³å£°èªè­˜ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆ
            if isinstance(transcription_result, str):
                return transcription_result                     # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãã®ã¾ã¾è¿”ã™
            
            # é€²æ—è¡¨ç¤ºï¼ˆã‚¹ãƒ†ãƒƒãƒ—3ï¼‰
            if progress_callback:
                progress_callback("æ—¥æœ¬èªã«ç¿»è¨³ä¸­...")
            
            # å­—å¹•ã‚»ã‚°ãƒ¡ãƒ³ãƒˆä½œæˆï¼ˆç¿»è¨³å«ã‚€ï¼‰
            subtitle_segments = self.create_subtitle_segments(transcription_result)
            
            # é€²æ—è¡¨ç¤ºï¼ˆå®Œäº†ï¼‰
            if progress_callback:
                progress_callback("å®Œäº†ï¼")
            
            # å‡¦ç†çµæœã‚’è¾æ›¸å½¢å¼ã§è¿”ã™
            return {
                'segments': subtitle_segments,                  # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±
                'original_text': transcription_result.get('text', ''),  # å…ƒã®è‹±èªãƒ†ã‚­ã‚¹ãƒˆ
                'duration': transcription_result.get('duration', 0)     # éŸ³å£°ã®é•·ã•
            }
            
        except Exception as e:                                  # äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼
            return f"å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}"                           # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™

class SubtitleGeneratorGUI:
    """
    å­—å¹•ç”Ÿæˆãƒ„ãƒ¼ãƒ«ã®GUIã‚¯ãƒ©ã‚¹
    tkinterã‚’ä½¿ç”¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›
    """
    
    def __init__(self):
        """
        GUIã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
        """
        # ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå¤±æ•—ã—ã¦ã„ãŸå ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
        if not IMPORTS_OK:
            return
        
        # å„ç¨®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆæœŸåŒ–
        self.config_manager = ConfigManager()                   # è¨­å®šç®¡ç†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        self.subtitle_gen = EnglishToJapaneseSubtitle()         # å­—å¹•ç”Ÿæˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        self.current_segments = None                            # ç¾åœ¨ã®å­—å¹•ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
        
        # GUIä½œæˆã¨è¨­å®šèª­ã¿è¾¼ã¿
        self.setup_gui()                                        # GUIè¦ç´ ã‚’ä½œæˆ
        self.load_saved_settings()                              # ä¿å­˜æ¸ˆã¿è¨­å®šã‚’èª­ã¿è¾¼ã¿
    
    def setup_gui(self):
        """
        GUIã®è¦ç´ ã‚’è¨­å®šãƒ»é…ç½®ã™ã‚‹
        ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ãƒœã‚¿ãƒ³ã€ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ãªã©ã‚’ä½œæˆ
        """
        # ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ä½œæˆã¨è¨­å®š
        self.root = tk.Tk()                                     # ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ
        self.root.title("è‹±èªéŸ³å£°â†’æ—¥æœ¬èªå­—å¹•ç”Ÿæˆãƒ„ãƒ¼ãƒ«ï¼ˆWAVå°‚ç”¨ï¼‰")  # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¿ã‚¤ãƒˆãƒ«
        self.root.geometry("1000x800")                          # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºï¼ˆå¹…xé«˜ã•ï¼‰
        
        # ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®ä½œæˆ
        menubar = tk.Menu(self.root)                            # ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
        self.root.config(menu=menubar)                          # ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¨­å®š
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ä½œæˆ
        file_menu = tk.Menu(menubar, tearoff=0)                 # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ä½œæˆï¼ˆåˆ‡ã‚Šé›¢ã—ä¸å¯ï¼‰
        menubar.add_cascade(label="ãƒ•ã‚¡ã‚¤ãƒ«", menu=file_menu)   # ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã«è¿½åŠ 
        file_menu.add_command(label="WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã", command=self.open_file)      # ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®è¿½åŠ 
        file_menu.add_separator()                               # åŒºåˆ‡ã‚Šç·šè¿½åŠ 
        file_menu.add_command(label="SRTå­—å¹•ã‚’ä¿å­˜", command=self.save_srt)          # ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®è¿½åŠ 
        file_menu.add_command(label="å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜", command=self.save_bilingual_text)  # ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®è¿½åŠ 
        file_menu.add_separator()                               # åŒºåˆ‡ã‚Šç·šè¿½åŠ 
        file_menu.add_command(label="çµ‚äº†", command=self.root.quit)                  # çµ‚äº†ãƒ¡ãƒ‹ãƒ¥ãƒ¼
        
        # ãƒ„ãƒ¼ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ä½œæˆ
        tools_menu = tk.Menu(menubar, tearoff=0)                # ãƒ„ãƒ¼ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ä½œæˆ
        menubar.add_cascade(label="ãƒ„ãƒ¼ãƒ«", menu=tools_menu)    # ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã«è¿½åŠ 
        tools_menu.add_command(label="éŸ³å£°å¤‰æ›ãƒ„ãƒ¼ãƒ«æƒ…å ±", command=self.show_conversion_help)  # ãƒ˜ãƒ«ãƒ—
        
        # è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ä½œæˆ
        settings_menu = tk.Menu(menubar, tearoff=0)             # è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ä½œæˆ
        menubar.add_cascade(label="è¨­å®š", menu=settings_menu)   # ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã«è¿½åŠ 
        settings_menu.add_command(label="APIè¨­å®š", command=self.show_api_settings)   # APIè¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚°
        
        # ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½œæˆï¼ˆå…¨ä½“ã®ã‚³ãƒ³ãƒ†ãƒŠï¼‰
        main_frame = tk.Frame(self.root)                        # ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)  # å…¨ä½“ã«åºƒãŒã‚‹ã‚ˆã†é…ç½®
        
        # APIè¨­å®šãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½œæˆ
        api_frame = ttk.LabelFrame(main_frame, text="OpenAI APIè¨­å®š")  # ãƒ©ãƒ™ãƒ«ä»˜ããƒ•ãƒ¬ãƒ¼ãƒ 
        api_frame.pack(fill=tk.X, pady=(0, 10))                # æ¨ªå¹…ã„ã£ã±ã„ã«é…ç½®
        
        # APIã‚­ãƒ¼å…¥åŠ›æ¬„ã®ä½œæˆ
        tk.Label(api_frame, text="APIã‚­ãƒ¼:").pack(side=tk.LEFT, padx=5)  # ãƒ©ãƒ™ãƒ«
        self.api_key_var = tk.StringVar()                       # ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ç”¨å¤‰æ•°
        api_entry = tk.Entry(api_frame, textvariable=self.api_key_var, show="*", width=40)  # å…¥åŠ›æ¬„ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å½¢å¼ï¼‰
        api_entry.pack(side=tk.LEFT, padx=5)                    # å·¦å¯„ã›ã§é…ç½®
        tk.Button(api_frame, text="è¨­å®š", command=self.set_api_key).pack(side=tk.LEFT, padx=5)  # è¨­å®šãƒœã‚¿ãƒ³
        self.api_status_label = tk.Label(api_frame, text="æœªè¨­å®š", fg="red")  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºï¼ˆåˆæœŸã¯èµ¤è‰²ï¼‰
        self.api_status_label.pack(side=tk.LEFT, padx=5)        # å·¦å¯„ã›ã§é…ç½®
        
        # æ“ä½œãƒœã‚¿ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½œæˆ
        button_frame = tk.Frame(main_frame)                     # ãƒœã‚¿ãƒ³é…ç½®ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        button_frame.pack(fill=tk.X, pady=(0, 10))              # æ¨ªå¹…ã„ã£ã±ã„ã«é…ç½®
        
        # ãƒ¡ã‚¤ãƒ³æ“ä½œãƒœã‚¿ãƒ³ã®ä½œæˆ
        tk.Button(button_frame, text="ğŸµ WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ", 
                 command=self.open_file, width=20, bg="#4CAF50", fg="white", 
                 font=("", 12, "bold")).pack(side=tk.LEFT, padx=(0, 10))  # ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒœã‚¿ãƒ³ï¼ˆç·‘è‰²ï¼‰
        tk.Button(button_frame, text="ğŸ”§ éŸ³å£°å¤‰æ›ãƒ˜ãƒ«ãƒ—", 
                 command=self.show_conversion_help, width=15, bg="#9C27B0", fg="white").pack(side=tk.LEFT, padx=(0, 10))  # ãƒ˜ãƒ«ãƒ—ãƒœã‚¿ãƒ³ï¼ˆç´«è‰²ï¼‰
        tk.Button(button_frame, text="ğŸ—‘ï¸ çµæœã‚’ã‚¯ãƒªã‚¢", 
                 command=self.clear_result, width=15).pack(side=tk.LEFT, padx=(0, 10))  # ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
        
        # ä¿å­˜ãƒœã‚¿ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½œæˆ
        save_frame = tk.Frame(button_frame)                     # ä¿å­˜ãƒœã‚¿ãƒ³å°‚ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        save_frame.pack(side=tk.RIGHT)                          # å³å¯„ã›ã§é…ç½®
        tk.Button(save_frame, text="ğŸ’¾ SRTå­—å¹•ä¿å­˜", 
                 command=self.save_srt, width=12, bg="#2196F3", fg="white").pack(side=tk.LEFT, padx=(0, 5))  # SRTä¿å­˜ï¼ˆé’è‰²ï¼‰
        tk.Button(save_frame, text="ğŸ“„ å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜", 
                 command=self.save_bilingual_text, width=15, bg="#FF9800", fg="white").pack(side=tk.LEFT)  # ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜ï¼ˆæ©™è‰²ï¼‰
        
        # æ³¨æ„æ›¸ããƒ•ãƒ¬ãƒ¼ãƒ ã®ä½œæˆ
        note_frame = tk.Frame(main_frame)                       # æ³¨æ„æ›¸ãç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        note_frame.pack(fill=tk.X, pady=(0, 10))                # æ¨ªå¹…ã„ã£ã±ã„ã«é…ç½®
        note_label = tk.Label(note_frame, text="ğŸ“Œ ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å¯¾å¿œï¼ˆFFmpegä¸è¦ãƒ»è»½é‡ç‰ˆï¼‰", 
                             fg="blue", font=("", 10, "bold"))  # æ³¨æ„æ›¸ããƒ†ã‚­ã‚¹ãƒˆï¼ˆé’è‰²ãƒ»å¤ªå­—ï¼‰
        note_label.pack()                                       # ä¸­å¤®é…ç½®
        
        # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ï¼ˆé€²æ—è¡¨ç¤ºï¼‰ã®ä½œæˆ
        self.progress_var = tk.StringVar()                      # é€²æ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”¨å¤‰æ•°
        self.progress_label = tk.Label(main_frame, textvariable=self.progress_var, fg="blue")  # é€²æ—ãƒ©ãƒ™ãƒ«ï¼ˆé’è‰²ï¼‰
        self.progress_label.pack(fill=tk.X, pady=(0, 10))       # æ¨ªå¹…ã„ã£ã±ã„ã«é…ç½®
        
        # ã‚¿ãƒ–è¨­å®šï¼ˆè¤‡æ•°ã®è¡¨ç¤ºæ–¹å¼ã‚’åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ï¼‰
        notebook = ttk.Notebook(main_frame)                     # ã‚¿ãƒ–ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆ
        notebook.pack(fill=tk.BOTH, expand=True)                # æ®‹ã‚Šã‚¹ãƒšãƒ¼ã‚¹ã‚’å…¨ã¦ä½¿ç”¨
        
        # å¯¾è¨³è¡¨ç¤ºã‚¿ãƒ–ã®ä½œæˆ
        bilingual_frame = ttk.Frame(notebook)                   # å¯¾è¨³ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        notebook.add(bilingual_frame, text="ğŸ“– è‹±æ—¥å¯¾è¨³")       # ã‚¿ãƒ–ã«è¿½åŠ 
        
        # å¯¾è¨³è¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢
        self.bilingual_text = scrolledtext.ScrolledText(bilingual_frame, height=25, width=100, 
                                                       font=("", 11))  # ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä»˜ããƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢
        self.bilingual_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)  # å…¨ä½“ã«åºƒãŒã‚‹ã‚ˆã†é…ç½®
        
        # SRTå­—å¹•ã‚¿ãƒ–ã®ä½œæˆ
        srt_frame = ttk.Frame(notebook)                         # SRTç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        notebook.add(srt_frame, text="ğŸ¬ SRTå­—å¹•")              # ã‚¿ãƒ–ã«è¿½åŠ 
        
        # SRTè¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢
        self.srt_text = scrolledtext.ScrolledText(srt_frame, height=25, width=100, 
                                                 font=("Courier", 10))  # ç­‰å¹…ãƒ•ã‚©ãƒ³ãƒˆã§SRTå½¢å¼ã‚’è¦‹ã‚„ã™ã
        self.srt_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)  # å…¨ä½“ã«åºƒãŒã‚‹ã‚ˆã†é…ç½®
        
        # æ—¥æœ¬èªã®ã¿ã‚¿ãƒ–ã®ä½œæˆ
        japanese_frame = ttk.Frame(notebook)                    # æ—¥æœ¬èªå°‚ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        notebook.add(japanese_frame, text="ğŸ—¾ æ—¥æœ¬èªå­—å¹•ã®ã¿")  # ã‚¿ãƒ–ã«è¿½åŠ 
        
        # æ—¥æœ¬èªè¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢
        self.japanese_text = scrolledtext.ScrolledText(japanese_frame, height=25, width=100, 
                                                      font=("", 12))  # å°‘ã—å¤§ãã‚ã®ãƒ•ã‚©ãƒ³ãƒˆ
        self.japanese_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)  # å…¨ä½“ã«åºƒãŒã‚‹ã‚ˆã†é…ç½®
        
        # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã®ä½œæˆ
        self.status_var = tk.StringVar()                        # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”¨å¤‰æ•°
        self.status_var.set("OpenAI APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„")  # åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        status_bar = tk.Label(self.root, textvariable=self.status_var, 
                             relief=tk.SUNKEN, anchor=tk.W)      # ãã¼ã‚“ã è¦‹ãŸç›®ã€å·¦å¯„ã›
        status_bar.pack(side=tk.BOTTOM, fill=tk.X)              # ä¸‹éƒ¨ã«æ¨ªå¹…ã„ã£ã±ã„ã§é…ç½®
    
    def show_conversion_help(self):
        """
        éŸ³å£°å¤‰æ›ãƒ˜ãƒ«ãƒ—ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã™ã‚‹
        WAVãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ–¹æ³•ã®è©³ç´°ãªèª¬æ˜ã‚’æä¾›
        """
        # ãƒ˜ãƒ«ãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ
        help_window = tk.Toplevel(self.root)                    # æ–°ã—ã„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
        help_window.title("éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›æ–¹æ³•")               # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¿ã‚¤ãƒˆãƒ«
        help_window.geometry("600x500")                         # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
        help_window.transient(self.root)                        # ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«å¾“å±
        
        # ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆã®å†…å®¹
        help_text = """ğŸ”§ éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›æ–¹æ³•

ã“ã®ãƒ„ãƒ¼ãƒ«ã¯WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚
ä»–ã®å½¢å¼ï¼ˆMP3, M4Aç­‰ï¼‰ã¯äº‹å‰ã«WAVã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚

ã€ç„¡æ–™å¤‰æ›ãƒ„ãƒ¼ãƒ«ã€‘

1ï¸âƒ£ Audacityï¼ˆæ¨å¥¨ï¼‰
   â€¢ https://www.audacityteam.org/
   â€¢ ã‚¤ãƒ³ãƒãƒ¼ãƒˆ â†’ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ â†’ WAVé¸æŠ

2ï¸âƒ£ VLC Media Player
   â€¢ ãƒ¡ãƒ‡ã‚£ã‚¢ â†’ å¤‰æ›/ä¿å­˜
   â€¢ ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã§WAVã‚’é¸æŠ

3ï¸âƒ£ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¤‰æ›ã‚µã‚¤ãƒˆ
   â€¢ https://convertio.co/ja/
   â€¢ https://online-audio-converter.com/ja/

4ï¸âƒ£ Windowsæ¨™æº–ï¼ˆPowerShellï¼‰
   ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦å®Ÿè¡Œï¼š

---ã‚³ãƒãƒ³ãƒ‰é–‹å§‹---
Add-Type -AssemblyName System.Windows.Forms
$openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
$openFileDialog.Filter = "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«|*.mp3;*.m4a;*.flac;*.ogg"
$result = $openFileDialog.ShowDialog()
if ($result -eq "OK") {
    $inputFile = $openFileDialog.FileName
    $outputFile = [System.IO.Path]::GetDirectoryName($inputFile) + "\\" + [System.IO.Path]::GetFileNameWithoutExtension($inputFile) + ".wav"
    Write-Host "å¤‰æ›ä¸­: $inputFile â†’ $outputFile"
    # ã“ã“ã§ffmpegã‚³ãƒãƒ³ãƒ‰ãŒå¿…è¦
}
---ã‚³ãƒãƒ³ãƒ‰çµ‚äº†---

ã€å¤‰æ›è¨­å®šæ¨å¥¨å€¤ã€‘
â€¢ ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ: 16000Hz ã¾ãŸã¯ 44100Hz
â€¢ ãƒ“ãƒƒãƒˆæ·±åº¦: 16bit
â€¢ ãƒãƒ£ãƒ³ãƒãƒ«: ãƒ¢ãƒãƒ©ãƒ«ï¼ˆ1ãƒãƒ£ãƒ³ãƒãƒ«ï¼‰æ¨å¥¨
â€¢ ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 25MBä»¥ä¸‹

ã€YouTubeã‹ã‚‰éŸ³å£°æŠ½å‡ºã€‘
â€¢ yt-dlp --extract-audio --audio-format wav [URL]
"""
        
        # ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºã™ã‚‹ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆ
        text_widget = scrolledtext.ScrolledText(help_window, font=("", 10))  # ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä»˜ããƒ†ã‚­ã‚¹ãƒˆ
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)        # å…¨ä½“ã«åºƒãŒã‚‹ã‚ˆã†é…ç½®
        text_widget.insert(1.0, help_text)                     # ãƒ†ã‚­ã‚¹ãƒˆã‚’æŒ¿å…¥
        text_widget.config(state=tk.DISABLED)                  # èª­ã¿å–ã‚Šå°‚ç”¨ã«ã™ã‚‹
        
        # é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
        close_button = tk.Button(help_window, text="é–‰ã˜ã‚‹", command=help_window.destroy)
        close_button.pack(pady=10)                              # ä¸‹éƒ¨ã«é…ç½®
    
    def load_saved_settings(self):
        """
        ä¿å­˜ã•ã‚ŒãŸè¨­å®šã‚’èª­ã¿è¾¼ã‚€
        å‰å›å…¥åŠ›ã—ãŸAPIã‚­ãƒ¼ãªã©ã‚’å¾©å…ƒ
        """
        api_key = self.config_manager.get_api_key()             # ä¿å­˜ã•ã‚ŒãŸAPIã‚­ãƒ¼ã‚’å–å¾—
        if api_key:                                             # APIã‚­ãƒ¼ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹å ´åˆ
            self.api_key_var.set(api_key)                       # å…¥åŠ›æ¬„ã«è¨­å®š
            self.set_api_key(show_message=False)                # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãªã—ã§è¨­å®š
    
    def set_api_key(self, show_message=True):
        """
        APIã‚­ãƒ¼ã‚’è¨­å®šã™ã‚‹
        Args:
            show_message: æˆåŠŸ/å¤±æ•—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹ã‹ã©ã†ã‹
        """
        api_key = self.api_key_var.get().strip()                # å…¥åŠ›ã•ã‚ŒãŸAPIã‚­ãƒ¼ã‚’å–å¾—ã—ç©ºç™½å‰Šé™¤
        if not api_key:                                         # APIã‚­ãƒ¼ãŒç©ºã®å ´åˆ
            if show_message:                                    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãƒ•ãƒ©ã‚°ãŒTrueã®å ´åˆ
                messagebox.showwarning("è­¦å‘Š", "APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")  # è­¦å‘Šãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
            return                                              # å‡¦ç†ã‚’çµ‚äº†
        
        # APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãƒ†ã‚¹ãƒˆ
        success = self.subtitle_gen.set_api_key(api_key)        # APIã‚­ãƒ¼è¨­å®šã‚’è©¦è¡Œ
        if success:                                             # è¨­å®šæˆåŠŸã®å ´åˆ
            self.config_manager.set_api_key(api_key)            # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            self.api_status_label.config(text="âœ“ è¨­å®šæ¸ˆã¿", fg="green")  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç·‘è‰²ã§æ›´æ–°
            self.status_var.set("æº–å‚™å®Œäº†")                     # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã‚’æ›´æ–°
            if show_message:                                    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãƒ•ãƒ©ã‚°ãŒTrueã®å ´åˆ
                messagebox.showinfo("æˆåŠŸ", "APIã‚­ãƒ¼ãŒæ­£å¸¸ã«è¨­å®šã•ã‚Œã¾ã—ãŸ")  # æˆåŠŸãƒ€ã‚¤ã‚¢ãƒ­ã‚°
        else:                                                   # è¨­å®šå¤±æ•—ã®å ´åˆ
            self.api_status_label.config(text="âœ— ã‚¨ãƒ©ãƒ¼", fg="red")  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’èµ¤è‰²ã§æ›´æ–°
            self.status_var.set("APIã‚­ãƒ¼ã‚¨ãƒ©ãƒ¼")                # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã‚’æ›´æ–°
            if show_message:                                    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãƒ•ãƒ©ã‚°ãŒTrueã®å ´åˆ
                messagebox.showerror("ã‚¨ãƒ©ãƒ¼", "APIã‚­ãƒ¼ãŒç„¡åŠ¹ã§ã™")  # ã‚¨ãƒ©ãƒ¼ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    
    def show_api_settings(self):
        """
        APIè¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã™ã‚‹
        APIã‚­ãƒ¼ã®å–å¾—æ–¹æ³•ã¨æ–™é‡‘æƒ…å ±ã‚’æä¾›
        """
        # è¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ
        dialog = tk.Toplevel(self.root)                         # æ–°ã—ã„ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
        dialog.title("OpenAI APIè¨­å®š")                          # ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¿ã‚¤ãƒˆãƒ«
        dialog.geometry("500x300")                              # ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚µã‚¤ã‚º
        dialog.transient(self.root)                             # ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«å¾“å±
        dialog.grab_set()                                       # ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã«ã™ã‚‹
        
        # æƒ…å ±ãƒ†ã‚­ã‚¹ãƒˆ
        info_text = """OpenAI APIã‚­ãƒ¼ã®å–å¾—æ–¹æ³•ï¼š

1. https://platform.openai.com/ ã«ã‚¢ã‚¯ã‚»ã‚¹
2. ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã¾ãŸã¯ãƒ­ã‚°ã‚¤ãƒ³
3. API Keys ãƒšãƒ¼ã‚¸ã«ç§»å‹•
4. "Create new secret key" ã‚’ã‚¯ãƒªãƒƒã‚¯
5. ç”Ÿæˆã•ã‚ŒãŸã‚­ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ä¸‹è¨˜ã«å…¥åŠ›

æ–™é‡‘ï¼ˆç›®å®‰ï¼‰ï¼š
- Whisper API: $0.006/åˆ†ï¼ˆç´„0.9å††/åˆ†ï¼‰
- GPT-4ç¿»è¨³: $0.03/1000ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆç´„4.5å††/1000æ–‡å­—ï¼‰
"""
        
        # æƒ…å ±ãƒ©ãƒ™ãƒ«
        tk.Label(dialog, text=info_text, justify=tk.LEFT, font=("", 10)).pack(padx=20, pady=10)
        
        # APIã‚­ãƒ¼å…¥åŠ›æ¬„
        key_frame = tk.Frame(dialog)                            # å…¥åŠ›æ¬„ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        key_frame.pack(padx=20, pady=10, fill=tk.X)             # æ¨ªå¹…ã„ã£ã±ã„ã«é…ç½®
        
        tk.Label(key_frame, text="APIã‚­ãƒ¼:").pack(side=tk.LEFT)  # ãƒ©ãƒ™ãƒ«
        key_entry = tk.Entry(key_frame, textvariable=self.api_key_var, width=50)  # å…¥åŠ›æ¬„
        key_entry.pack(side=tk.LEFT, padx=10, fill=tk.X, expand=True)  # æ®‹ã‚Šã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½¿ç”¨
        
        # ãƒœã‚¿ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ 
        button_frame = tk.Frame(dialog)                         # ãƒœã‚¿ãƒ³é…ç½®ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
        button_frame.pack(pady=20)                              # ä¸‹éƒ¨ã«é…ç½®
        
        # è¨­å®šãƒœã‚¿ãƒ³ï¼ˆãƒ©ãƒ ãƒ€å¼ã§è¤‡æ•°ã®å‡¦ç†ã‚’å®Ÿè¡Œï¼‰
        tk.Button(button_frame, text="è¨­å®š", 
                 command=lambda: [self.set_api_key(), dialog.destroy()]).pack(side=tk.LEFT, padx=5)
        # ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³
        tk.Button(button_frame, text="ã‚­ãƒ£ãƒ³ã‚»ãƒ«", command=dialog.destroy).pack(side=tk.LEFT, padx=5)
    
    def update_progress(self, message):
        """
        ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹
        Args:
            message: è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        """
        self.progress_var.set(message)                          # é€²æ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¨­å®š
        self.root.update()                                      # GUIç”»é¢ã‚’å³åº§ã«æ›´æ–°
    
    def open_file(self):
        """
        WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ã¦å‡¦ç†ã™ã‚‹
        ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠâ†’éŸ³å£°èªè­˜â†’ç¿»è¨³â†’çµæœè¡¨ç¤ºã®å…¨å·¥ç¨‹ã‚’å®Ÿè¡Œ
        """
        # APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        if self.subtitle_gen.client is None:
            messagebox.showerror("ã‚¨ãƒ©ãƒ¼", "OpenAI APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„")
            return                                              # å‡¦ç†ã‚’ä¸­æ–­
        
        # ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
        file_path = filedialog.askopenfilename(
            title="è‹±èªWAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ",                       # ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¿ã‚¤ãƒˆãƒ«
            filetypes=[                                         # ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                ("WAVãƒ•ã‚¡ã‚¤ãƒ«", "*.wav"),                       # WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿
                ("ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«", "*.*")                     # å¿µã®ãŸã‚å…¨ãƒ•ã‚¡ã‚¤ãƒ«
            ]
        )
        
        if file_path:                                           # ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚ŒãŸå ´åˆ
            self.status_var.set("å‡¦ç†ä¸­...")                   # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            
            def process_thread():
                """
                éŸ³å£°å‡¦ç†ã‚’åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã™ã‚‹é–¢æ•°
                GUIã®å¿œç­”æ€§ã‚’ä¿ã¤ãŸã‚ã«åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§é‡ã„å‡¦ç†ã‚’å®Ÿè¡Œ
                """
                try:
                    # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚’å®Ÿè¡Œ
                    result = self.subtitle_gen.process_wav_file(file_path, self.update_progress)
                    
                    if isinstance(result, str):                 # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¿”ã•ã‚ŒãŸå ´åˆ
                        messagebox.showerror("ã‚¨ãƒ©ãƒ¼", result)  # ã‚¨ãƒ©ãƒ¼ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
                        self.status_var.set("ã‚¨ãƒ©ãƒ¼")           # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
                        return                                  # å‡¦ç†ã‚’çµ‚äº†
                    
                    # æˆåŠŸã®å ´åˆ
                    self.current_segments = result['segments']  # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’ä¿å­˜
                    self.display_results(result, os.path.basename(file_path))  # çµæœã‚’è¡¨ç¤º
                    self.status_var.set("å‡¦ç†å®Œäº†")             # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
                    self.progress_var.set("")                   # é€²æ—è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢
                    
                except Exception as e:                          # äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼
                    messagebox.showerror("ã‚¨ãƒ©ãƒ¼", f"å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
                    self.status_var.set("ã‚¨ãƒ©ãƒ¼")               # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
                    self.progress_var.set("")                   # é€²æ—è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢
            
            # åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†ã‚’é–‹å§‹ï¼ˆdaemon=Trueã§ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰çµ‚äº†æ™‚ã«è‡ªå‹•çµ‚äº†ï¼‰
            threading.Thread(target=process_thread, daemon=True).start()
    
    def display_results(self, result, filename):
        """
        å‡¦ç†çµæœã‚’å„ã‚¿ãƒ–ã«è¡¨ç¤ºã™ã‚‹
        Args:
            result: å‡¦ç†çµæœã®è¾æ›¸
            filename: ãƒ•ã‚¡ã‚¤ãƒ«å
        """
        segments = result['segments']                           # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’å–å¾—
        
        # å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
        bilingual_content = self.subtitle_gen.generate_bilingual_text(segments)  # å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ
        bilingual_content = f"ãƒ•ã‚¡ã‚¤ãƒ«: {filename}\n\n" + bilingual_content      # ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¿½åŠ 
        self.bilingual_text.delete(1.0, tk.END)                # æ—¢å­˜å†…å®¹ã‚’ã‚¯ãƒªã‚¢
        self.bilingual_text.insert(1.0, bilingual_content)     # æ–°ã—ã„å†…å®¹ã‚’æŒ¿å…¥
        
        # SRTå­—å¹•è¡¨ç¤º
        srt_content = self.subtitle_gen.generate_srt_content(segments)  # SRTå†…å®¹ç”Ÿæˆ
        self.srt_text.delete(1.0, tk.END)                      # æ—¢å­˜å†…å®¹ã‚’ã‚¯ãƒªã‚¢
        self.srt_text.insert(1.0, srt_content)                 # æ–°ã—ã„å†…å®¹ã‚’æŒ¿å…¥
        
        # æ—¥æœ¬èªã®ã¿è¡¨ç¤º
        japanese_content = f"ãƒ•ã‚¡ã‚¤ãƒ«: {filename}\n"           # ãƒ˜ãƒƒãƒ€ãƒ¼ä½œæˆ
        japanese_content += "=" * 50 + "\n\n"                  # åŒºåˆ‡ã‚Šç·š
        for i, segment in enumerate(segments, 1):               # å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å‡¦ç†
            japanese_content += f"{i:02d}. {segment['japanese']}\n\n"  # ç•ªå·ä»˜ãã§æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ
        
        self.japanese_text.delete(1.0, tk.END)                 # æ—¢å­˜å†…å®¹ã‚’ã‚¯ãƒªã‚¢
        self.japanese_text.insert(1.0, japanese_content)       # æ–°ã—ã„å†…å®¹ã‚’æŒ¿å…¥
    
    def save_srt(self):
        """
        SRTå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã™ã‚‹
        å‹•ç”»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ä½¿ç”¨å¯èƒ½ãªæ¨™æº–å­—å¹•å½¢å¼ã§å‡ºåŠ›
        """
        # ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        if not self.current_segments:
            messagebox.showwarning("è­¦å‘Š", "ä¿å­˜ã™ã‚‹å­—å¹•ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
            return                                              # å‡¦ç†ã‚’ä¸­æ–­
        
        # ä¿å­˜å…ˆãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°
        file_path = filedialog.asksaveasfilename(
            title="SRTå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜",                      # ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¿ã‚¤ãƒˆãƒ«
            defaultextension=".srt",                            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ‹¡å¼µå­
            filetypes=[("SRTå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«", "*.srt"), ("ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«", "*.*")]  # ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼
        )
        
        if file_path:                                           # ä¿å­˜å…ˆãŒé¸æŠã•ã‚ŒãŸå ´åˆ
            try:
                # SRTå†…å®¹ã‚’ç”Ÿæˆ
                srt_content = self.subtitle_gen.generate_srt_content(self.current_segments)
                # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿ï¼ˆUTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(srt_content)                        # SRTå†…å®¹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
                
                # æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
                messagebox.showinfo("æˆåŠŸ", f"SRTå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸ:\n{os.path.basename(file_path)}")
                self.status_var.set(f"SRTä¿å­˜å®Œäº†: {os.path.basename(file_path)}")  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            except Exception as e:                              # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼
                messagebox.showerror("ã‚¨ãƒ©ãƒ¼", f"ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
    
    def save_bilingual_text(self):
        """
        å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã™ã‚‹
        å­¦ç¿’ã‚„ç¢ºèªç”¨ã®èª­ã¿ã‚„ã™ã„å½¢å¼ã§å‡ºåŠ›
        """
        # ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        if not self.current_segments:
            messagebox.showwarning("è­¦å‘Š", "ä¿å­˜ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
            return                                              # å‡¦ç†ã‚’ä¸­æ–­
        
        # ä¿å­˜å…ˆãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°
        file_path = filedialog.asksaveasfilename(
            title="å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜",                  # ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¿ã‚¤ãƒˆãƒ«
            defaultextension=".txt",                            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ‹¡å¼µå­
            filetypes=[("ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«", "*.txt"), ("ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«", "*.*")]  # ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼
        )
        
        if file_path:                                           # ä¿å­˜å…ˆãŒé¸æŠã•ã‚ŒãŸå ´åˆ
            try:
                # å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆå†…å®¹ã‚’ç”Ÿæˆ
                text_content = self.subtitle_gen.generate_bilingual_text(self.current_segments)
                # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿ï¼ˆUTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(text_content)                       # ãƒ†ã‚­ã‚¹ãƒˆå†…å®¹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
                
                # æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
                messagebox.showinfo("æˆåŠŸ", f"å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸ:\n{os.path.basename(file_path)}")
                self.status_var.set(f"ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜å®Œäº†: {os.path.basename(file_path)}")  # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            except Exception as e:                              # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼
                messagebox.showerror("ã‚¨ãƒ©ãƒ¼", f"ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
    
    def clear_result(self):
        """
        è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹çµæœã‚’ã™ã¹ã¦ã‚¯ãƒªã‚¢ã™ã‚‹
        """
        self.bilingual_text.delete(1.0, tk.END)                # å¯¾è¨³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
        self.srt_text.delete(1.0, tk.END)                      # SRTãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
        self.japanese_text.delete(1.0, tk.END)                 # æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
        self.current_segments = None                            # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
        self.progress_var.set("")                               # é€²æ—è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢
        self.status_var.set("ã‚¯ãƒªã‚¢å®Œäº†")                       # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
    
    def run(self):
        """
        GUIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã™ã‚‹
        ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ“ä½œã‚’å¾…æ©Ÿ
        """
        self.root.mainloop()                                    # tkinterã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹

class ConfigManager:
    """
    è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ç®¡ç†ã‚¯ãƒ©ã‚¹
    APIã‚­ãƒ¼ãªã©ã®è¨­å®šæƒ…å ±ã‚’æ°¸ç¶šåŒ–
    """
    
    def __init__(self):
        """
        è¨­å®šç®¡ç†ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
        """
        # ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå¤±æ•—ã—ã¦ã„ãŸå ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
        if not IMPORTS_OK:
            return
        
        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æº–å‚™
        self.config_file = "subtitle_config.ini"               # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«å
        self.config = configparser.ConfigParser()              # è¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        self.load_config()                                      # æ—¢å­˜è¨­å®šã‚’èª­ã¿è¾¼ã¿
    
    def load_config(self):
        """
        è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã‚€
        """
        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿èª­ã¿è¾¼ã¿
        if os.path.exists(self.config_file):
            # UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            self.config.read(self.config_file, encoding='utf-8')
    
    def save_config(self):
        """
        ç¾åœ¨ã®è¨­å®šã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã™ã‚‹
        """
        # UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
        with open(self.config_file, 'w', encoding='utf-8') as f:
            self.config.write(f)                                # è¨­å®šå†…å®¹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
    
    def get_api_key(self):
        """
        ä¿å­˜ã•ã‚Œã¦ã„ã‚‹APIã‚­ãƒ¼ã‚’å–å¾—ã™ã‚‹
        Returns:
            str: ä¿å­˜ã•ã‚Œã¦ã„ã‚‹APIã‚­ãƒ¼ï¼ˆãªã‘ã‚Œã°ç©ºæ–‡å­—åˆ—ï¼‰
        """
        # 'openai'ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®'api_key'ã‚­ãƒ¼ã‹ã‚‰å€¤ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç©ºæ–‡å­—åˆ—ï¼‰
        return self.config.get('openai', 'api_key', fallback='')
    
    def set_api_key(self, api_key):
        """
        APIã‚­ãƒ¼ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã™ã‚‹
        Args:
            api_key: ä¿å­˜ã™ã‚‹APIã‚­ãƒ¼
        """
        # 'openai'ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
        if 'openai' not in self.config:
            self.config.add_section('openai')                   # ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
        
        # APIã‚­ãƒ¼ã‚’è¨­å®š
        self.config.set('openai', 'api_key', api_key)           # ã‚­ãƒ¼ã¨å€¤ã‚’è¨­å®š
        self.save_config()                                      # ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜

def install_requirements():
    """
    å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è‡ªå‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹é–¢æ•°
    pip ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    """
    import subprocess                                           # å¤–éƒ¨ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œç”¨
    import sys                                                  # ã‚·ã‚¹ãƒ†ãƒ é–¢é€£
    
    # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒªã‚¹ãƒˆ
    required_packages = [
        'openai>=1.0.0'                                         # OpenAI APIãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆãƒãƒ¼ã‚¸ãƒ§ãƒ³1.0.0ä»¥ä¸Šï¼‰
    ]
    
    # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    print("å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸­...")
    print("=" * 40)                                             # åŒºåˆ‡ã‚Šç·š
    
    # å„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’é †ç•ªã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    for package in required_packages:
        try:
            print(f"ğŸ“¦ {package} ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸­...")            # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            
            # pip install ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
            print(f"âœ… {package} ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†")               # æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        except subprocess.CalledProcessError:                   # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¤±æ•—æ™‚
            print(f"âŒ {package} ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¤±æ•—")               # å¤±æ•—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    
    # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    print("\nğŸ‰ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†ï¼")
    print("ğŸ“Œ ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯WAVãƒ•ã‚¡ã‚¤ãƒ«å°‚ç”¨ï¼ˆè¶…è»½é‡ç‰ˆï¼‰")
    print("æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã§ãƒ„ãƒ¼ãƒ«ã‚’èµ·å‹•ã—ã¦ãã ã•ã„:")
    print("py wav_subtitle.py")
    input("\nEnterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦çµ‚äº†...")                        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›å¾…ã¡

def main():
    """
    ãƒ¡ã‚¤ãƒ³é–¢æ•° - ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
    ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®å‡¦ç†ã¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•
    """
    # èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    print("è‹±èªéŸ³å£°â†’æ—¥æœ¬èªå­—å¹•ç”Ÿæˆãƒ„ãƒ¼ãƒ«ï¼ˆWAVå°‚ç”¨ãƒ»FFmpegä¸è¦ç‰ˆï¼‰")
    print("=" * 70)                                             # åŒºåˆ‡ã‚Šç·š
    
    # ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã®ãƒã‚§ãƒƒã‚¯
    if not IMPORTS_OK:                                          # ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ãŸå ´åˆ
        print("âŒ å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        print(f"ã‚¨ãƒ©ãƒ¼: {MISSING_MODULE}")                      # ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’è¡¨ç¤º
        print("\nğŸ“¦ ä»¥ä¸‹ã®æ–¹æ³•ã§ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãã ã•ã„:")
        print("\næ–¹æ³•1: è‡ªå‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«")
        print("  py wav_subtitle.py --install")                 # è‡ªå‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰
        print("\næ–¹æ³•2: æ‰‹å‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«")
        print("  pip install openai>=1.0.0")                   # æ‰‹å‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰
        print("\nğŸ’¡ ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯æœ€è»½é‡ï¼ˆOpenAI APIã®ã¿å¿…è¦ï¼‰")
        input("\nEnterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦çµ‚äº†...")                    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›å¾…ã¡
        return                                                  # ãƒ—ãƒ­ã‚°ãƒ©ãƒ çµ‚äº†
    
    # ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®ãƒã‚§ãƒƒã‚¯
    if len(sys.argv) > 1 and sys.argv[1] == "--install":       # --install ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆ
        install_requirements()                                  # ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Ÿè¡Œ
        return                                                  # ãƒ—ãƒ­ã‚°ãƒ©ãƒ çµ‚äº†
    
    # GUIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•
    try:
        app = SubtitleGeneratorGUI()                            # GUIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
        app.run()                                               # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
    except Exception as e:                                      # èµ·å‹•ã‚¨ãƒ©ãƒ¼
        print(f"ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")     # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
        input("Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦çµ‚äº†...")                      # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›å¾…ã¡

# ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
if __name__ == "__main__":                                      # ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒç›´æ¥å®Ÿè¡Œã•ã‚ŒãŸå ´åˆ
    # ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ãŒã‚ã‚‹å ´åˆã§ã‚‚--installã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯å®Ÿè¡Œå¯èƒ½
    if not IMPORTS_OK and len(sys.argv) > 1 and sys.argv[1] == "--install":
        install_requirements()                                  # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Ÿè¡Œ
    else:
        main()                                                  # ãƒ¡ã‚¤ãƒ³é–¢æ•°å®Ÿè¡Œ
